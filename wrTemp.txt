



# <------------- GLOBALS ------------->
UGs_fire=list()
UGs_NoTModel=list()
interactionRounds # ticks

#Self-Defined parameters
T=100 #Temperature parameter (will decrease with time) for the choice between exploit & explore #A REGLER


# <------------- FUNCTIONS ------------->

#Trust value returned for provider b
#k is the component for which we want the trust value
function getT(k,a,b): #list au lieu de passer a,b et k on verra ->>> need to rewrite the signature of this function as we discuted
	#old version
	if(k==Component.IT or k==Component.WR){
		RList <- RW(a,b,c)
		if(k==Component.IT):
			RList <- RI(a,b,c)
		somme=0
		weightSum=0
		foreach r dans R(a,b,c):
			weight=(exp(-1*this.tick-r[i])/lambdaIT)
			weightSum+=weight
			somme+=weight*r[v]

		return somme/weightSum	


	#new version generique, on ajoutera des switches dans le modele qui nous permettent de savoir quels composants sont actifs
	# T(a,b) = (sum Wk * pTk(a,b) * Tk(a,b)) / (sum Wk * pTk(a,b))
	somme = 0
	weightSum = 0
		#ici il faut que l'agent fire ait 2 listes des providers distinctes dont l'une pour les interations directes et l'autre pour les indirectes (via WR)
	calcul somme et weightSum comme dessus
	if (Model.WR = True)
		rajouter des termes dans somme et weightSum
	if (Model.CR = True)
		pareil
	if (Model.RT = True)
		pareil
	return somme/weightSum
	}
	
	

#Reliability for trust value
function getReliability(a,b,TI):
	gamma =gammaI
	
	pD=0
	lambda=-5/ln(0.5)
	weightSum=0
	foreach r dans R(a,b,c):
		weight=(exp(-1*this.tick-r[i])/lambda)
		weightSum+=weight
		pD+= weight * abs (r[v] - TI)
	
	pD = 1 - pD/(2*weightSum)
	pR=1-exp(-1*gamma*weightSum)
	return pR*pD



## select provider 

function searchProvider:

	## without a trustModel we select randomly
	if modele == NoTrust:
		return selectRandomProvider()


	if modele == FIRE:
		#Separate known and unknown providers
		foreach providers p:
			if (getRatingFor(p) == empty):
				noTrustValue <- p
			else
				hasTrustValue <- p
		
		if(hasTrustValue==empty):
			return selectRandomProvider()
		if(noTrustValue==empty):
			return selectBestProvider()
		

		# store the best known provider
		bestP <- selectBestProvider()
		#expected performance value from this best provider
		ER_a1 <- getTI(self,bestP)

		averageUG=0
		foreach provider p:
			averageUG+=meanOf(p.pType.intervalle)
		averageUG /= totalPNb

		#expected performance value from all providers (known and unknown)
		ER_a2 <- averageUG
		#Two choices:
		#a2 selectRandomProvider	(explore)
		#a1 selectBestProvider		(exploit)

		#Temperature parameter decreases
		T/=1.5

		#Proba of choosing option 1 (exploit)
		pA1=(exp(ER_a1/T))/((exp(ER_a1/T))+(exp(ER_a2/T)))

		if (random (0,1 )< pA1):
			return bestP
		else:
			return selectRandomProvider()


# Choose best provider by selecting max of trust values
function selectBestProvider():
	bestV=-1000
	bestP=None
	foreach p in hasTrustValue:
		trustValue=getTI(self,p)
		if( trustValue> bestV):
			bestV <- trustValue
			bestP<-p
	############ call function : evaluationProcessWR ([], bestP, nBF, nRL, self.notesForBestP ?) not sure about this
	return bestP


function evaluationProcessWR:
	chain=0
	witnessNb=0
	ratingsList= []
	acquaintances = []

	#Initialization with his nearest neighbours
	while nbAcquaintances < nbF : 
		acquaintances +=choose nextNearestConsumer

	while (witnessNb < nBF and chain<nRL)
		chain ++
		ask firstnBFacquaintances 
			acquaintances.remove(self)
			if matchingRatingsFound :
				ratingsList.append (ratings])
				//If he had an interaction he is a witness
				witnessNb ++
			else
				acquaintances.append (listOFnewAcquaintances)
	RW = ratingsList
	TW = getTrustValue (RW)
	end

	




